#!/bin/bash
# repo-send - Send a git branch to a remote machine using git bundles over SSH
#
# Usage: repo-send [options] <host> [refspec]
#   Refspec: <local_branch>[:<repo_name>][@<remote_branch>]
#   -p, --path <path>   Remote repo path (overrides remote config)
#   -f, --full           Force full bundle (skip incremental)
#   -h, --help           Show help
#
# Config: ~/.repo-transfer/config on the REMOTE machine controls the default base_path.
# Env: HIVE_WORKER_NAME — if set, enables per-worker repo registration.

set -euo pipefail

# Source registry functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/repo-registry.sh"

# SSH identity (exported by hive main for per-worker quick-ssh)
HIVE_SSH_ID="${HIVE_SSH_ID:-}"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

usage() {
    cat <<EOF
Usage: repo-send [options] <host> [refspec]

Send a git branch to a remote machine via git bundle over SSH.
Automatically uses incremental bundles when possible.

The remote machine's ~/.repo-transfer/config controls the default
destination (base_path setting, defaults to ~).

Refspec format: <local_branch>[:<repo_name>][@<remote_branch>]
  main              Send local 'main' to remote repo (dir name), branch 'main'
  main:myapp-v2     Send local 'main' to remote 'myapp-v2', branch 'main'
  main@dev          Send local 'main' to remote repo (dir name), branch 'dev'
  main:myapp-v2@dev Send local 'main' to remote 'myapp-v2', branch 'dev'

Arguments:
  host      Remote hostname (Tailscale name, IP, or user@host)
  refspec   What to send (default: current branch, same repo name + branch)

Options:
  -p, --path <path>   Remote repo path (overrides remote config + repo name)
  -f, --full           Force full bundle (no incremental optimization)
  -h, --help           Show this help message

Examples:
  repo-send agent-vm
  repo-send agent-vm main
  repo-send agent-vm main:myapp-v2
  repo-send agent-vm main:myapp-v2@dev
  repo-send agent-vm main -p ~/projects/myapp
  repo-send user@10.0.0.5 dev --full
EOF
}

FULL=false
REMOTE_PATH=""
HOST=""
REFSPEC=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -p|--path) REMOTE_PATH="$2"; shift 2 ;;
        -f|--full) FULL=true; shift ;;
        -h|--help) usage; exit 0 ;;
        -*)
            echo -e "${RED}Unknown option: $1${NC}"
            usage; exit 1 ;;
        *)
            if [ -z "$HOST" ]; then HOST="$1"
            elif [ -z "$REFSPEC" ]; then REFSPEC="$1"
            else echo -e "${RED}Too many arguments${NC}"; usage; exit 1
            fi
            shift ;;
    esac
done

if [ -z "$HOST" ]; then
    echo -e "${RED}Error: host is required${NC}"
    usage
    exit 1
fi

# Verify we're in a git repo
REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null) || {
    echo -e "${RED}Error: not in a git repository${NC}"
    exit 1
}

DEFAULT_REPO_NAME=$(basename "$REPO_ROOT")

# Parse refspec
parse_refspec "$REFSPEC" "$DEFAULT_REPO_NAME"

# Default local branch to current branch
LOCAL_BRANCH="${PARSED_LOCAL_BRANCH}"
if [ -z "$LOCAL_BRANCH" ]; then
    LOCAL_BRANCH=$(git branch --show-current 2>/dev/null) || {
        echo -e "${RED}Error: not on a branch (detached HEAD) and no branch specified${NC}"
        exit 1
    }
    if [ -z "$LOCAL_BRANCH" ]; then
        echo -e "${RED}Error: not on a branch (detached HEAD) and no branch specified${NC}"
        exit 1
    fi
fi

REPO_NAME="$PARSED_REPO_NAME"
REMOTE_BRANCH="${PARSED_REMOTE_BRANCH:-$LOCAL_BRANCH}"

# Resolve repo name via per-worker registry (if worker name is available)
if [ -n "${HIVE_WORKER_NAME:-}" ]; then
    resolve_worker_repo_for_send "$HIVE_WORKER_NAME" "$REPO_NAME" "$REPO_ROOT" "$PARSED_REPO_EXPLICIT" || exit 1
    REPO_NAME="$RESOLVED_REPO_NAME"
fi

# Verify local branch exists
git rev-parse --verify "$LOCAL_BRANCH" >/dev/null 2>&1 || {
    echo -e "${RED}Error: branch '$LOCAL_BRANCH' does not exist${NC}"
    exit 1
}

# State tracking for incremental bundles
STATE_DIR="$HOME/.repo-transfer"
STATE_KEY=$(echo "${REPO_NAME}:${HOST}:${LOCAL_BRANCH}:${REMOTE_BRANCH}" | md5sum | cut -d' ' -f1)
STATE_FILE="$STATE_DIR/send/$STATE_KEY"

BRANCH_TIP=$(git rev-parse "$LOCAL_BRANCH")

# Create bundle
BUNDLE_FILE=$(mktemp "/tmp/${REPO_NAME}-XXXXXX.bundle")
trap "rm -f '$BUNDLE_FILE'" EXIT

echo -e "${BLUE}Sending${NC} ${LOCAL_BRANCH} → ${REPO_NAME}@${REMOTE_BRANCH}${HIVE_WORKER_NAME:+ on ${HIVE_WORKER_NAME}}"

if [ "$FULL" = false ] && [ -f "$STATE_FILE" ]; then
    LAST_COMMIT=$(cat "$STATE_FILE")
    if [ "$LAST_COMMIT" = "$BRANCH_TIP" ]; then
        echo -e "${YELLOW}[$REPO_NAME] Branch '$LOCAL_BRANCH' is unchanged since last send. Nothing to do.${NC}"
        exit 0
    fi
    if git merge-base --is-ancestor "$LAST_COMMIT" "$LOCAL_BRANCH" 2>/dev/null; then
        COMMIT_COUNT=$(git rev-list --count "$LAST_COMMIT..$LOCAL_BRANCH")
        echo -e "${BLUE}Creating incremental bundle ($COMMIT_COUNT new commits)...${NC}"
        git bundle create "$BUNDLE_FILE" "$LAST_COMMIT..$LOCAL_BRANCH" --
    else
        echo -e "${BLUE}Creating full bundle of '$LOCAL_BRANCH'...${NC}"
        git bundle create "$BUNDLE_FILE" "$LOCAL_BRANCH" --
    fi
else
    echo -e "${BLUE}Creating full bundle of '$LOCAL_BRANCH'...${NC}"
    git bundle create "$BUNDLE_FILE" "$LOCAL_BRANCH" --
fi

BUNDLE_SIZE=$(du -h "$BUNDLE_FILE" | cut -f1)
echo -e "Bundle: ${BUNDLE_SIZE}"

# Transfer
REMOTE_BUNDLE="/tmp/${REPO_NAME}-$(date +%s).bundle"
echo -e "${BLUE}Transferring to $HOST...${NC}"
scp $HIVE_SSH_ID -q "$BUNDLE_FILE" "$HOST:$REMOTE_BUNDLE"

# Apply on remote (let remote's config decide path unless -p was given)
# The apply logic is inlined here so the worker doesn't need hive installed.
echo -e "${BLUE}Applying on remote...${NC}"
ssh $HIVE_SSH_ID "$HOST" bash -s -- "$REMOTE_BUNDLE" "$LOCAL_BRANCH" "$REMOTE_BRANCH" "$REMOTE_PATH" "$REPO_NAME" <<'REMOTE_APPLY'
set -euo pipefail

BUNDLE="$1"
BUNDLE_BRANCH="$2"
LOCAL_BRANCH="$3"
EXPLICIT_PATH="$4"
REPO_NAME="$5"

# Load config for default base path
REPO_TRANSFER_BASE_PATH="$HOME"
CONFIG_FILE="$HOME/.repo-transfer/config"
if [ -f "$CONFIG_FILE" ]; then
    while IFS='=' read -r key value; do
        [[ "$key" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$key" ]] && continue
        key=$(echo "$key" | xargs)
        value=$(echo "$value" | xargs)
        value="${value/#\~/$HOME}"
        case "$key" in
            base_path) REPO_TRANSFER_BASE_PATH="$value" ;;
        esac
    done < "$CONFIG_FILE"
fi

# Determine target path
if [ -z "$EXPLICIT_PATH" ]; then
    TARGET_PATH="$REPO_TRANSFER_BASE_PATH/$REPO_NAME"
else
    TARGET_PATH="${EXPLICIT_PATH/#\~/$HOME}"
fi

if [ ! -d "$TARGET_PATH" ]; then
    # First time: clone from bundle
    echo "Creating new repo at $TARGET_PATH..."
    mkdir -p "$(dirname "$TARGET_PATH")"
    git clone "$BUNDLE" "$TARGET_PATH" -b "$BUNDLE_BRANCH"
    cd "$TARGET_PATH"
    git remote remove origin 2>/dev/null || true
    # Rename branch if local name differs from bundle branch
    if [ "$LOCAL_BRANCH" != "$BUNDLE_BRANCH" ]; then
        git branch -m "$BUNDLE_BRANCH" "$LOCAL_BRANCH"
    fi
    echo "Cloned and checked out '$LOCAL_BRANCH' at $TARGET_PATH"

elif [ ! -d "$TARGET_PATH/.git" ]; then
    echo "Error: $TARGET_PATH exists but is not a git repository" >&2
    exit 1

else
    # Existing repo: fetch from bundle and update branch
    cd "$TARGET_PATH"
    CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "")

    if [ "$CURRENT_BRANCH" = "$LOCAL_BRANCH" ]; then
        # On the target branch - check for uncommitted changes
        if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null; then
            echo "Warning: uncommitted changes on '$LOCAL_BRANCH' - stashing"
            git stash push -m "repo-apply auto-stash $(date +%Y%m%d-%H%M%S)"
        fi

        git fetch "$BUNDLE" "$BUNDLE_BRANCH"
        if git merge --ff-only FETCH_HEAD 2>/dev/null; then
            echo "Fast-forwarded '$LOCAL_BRANCH'"
        else
            echo "Cannot fast-forward. Resetting to received state..."
            git reset --hard FETCH_HEAD
            echo "Reset '$LOCAL_BRANCH' to received state"
        fi
    else
        # On a different branch - update the target ref directly
        git fetch "$BUNDLE" "$BUNDLE_BRANCH:$LOCAL_BRANCH"
        git checkout "$LOCAL_BRANCH"
        echo "Updated and checked out '$LOCAL_BRANCH'"
    fi

    echo "Repo updated at $TARGET_PATH"
fi

# Clean up the bundle
rm -f "$BUNDLE"
REMOTE_APPLY

# Record state for future incremental sends
mkdir -p "$(dirname "$STATE_FILE")"
echo "$BRANCH_TIP" > "$STATE_FILE"

DISPLAY_PATH="${REMOTE_PATH:-"<default>/$REPO_NAME"}"
echo -e "${GREEN}[$REPO_NAME] Sent ${LOCAL_BRANCH} → ${REPO_NAME}@${REMOTE_BRANCH} ($BRANCH_TIP) at $HOST:$DISPLAY_PATH${NC}"
