#!/bin/bash
# repo-fetch - Fetch a git branch from a remote machine using git bundles over SSH
#
# Usage: repo-fetch [options] <host> [branch]
#   -p, --path <path>   Remote repo path (overrides remote config)
#   -f, --full           Force full bundle (skip incremental)
#   -h, --help           Show help
#
# Config: ~/.repo-transfer/config on the REMOTE machine controls the default base_path.

set -euo pipefail

# Source registry functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/repo-registry.sh"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

usage() {
    cat <<EOF
Usage: repo-fetch [options] <host> [branch]

Fetch a git branch from a remote machine via git bundle over SSH.
The remote creates a bundle and sends it back for local application.

The remote machine's ~/.repo-transfer/config controls where repos
live (base_path setting, defaults to ~).

Arguments:
  host      Remote hostname (Tailscale name, IP, or user@host)
  branch    Branch to fetch (default: current branch)

Options:
  -p, --path <path>   Remote repo path (overrides remote config)
  -f, --full           Force full bundle (no incremental optimization)
  -h, --help           Show this help message

Examples:
  repo-fetch agent-vm
  repo-fetch agent-vm feature/login
  repo-fetch agent-vm main -p ~/projects/myapp
  repo-fetch user@10.0.0.5 dev --full
EOF
}

FULL=false
REMOTE_PATH=""
HOST=""
BRANCH=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -p|--path) REMOTE_PATH="$2"; shift 2 ;;
        -f|--full) FULL=true; shift ;;
        -h|--help) usage; exit 0 ;;
        -*)
            echo -e "${RED}Unknown option: $1${NC}"
            usage; exit 1 ;;
        *)
            if [ -z "$HOST" ]; then HOST="$1"
            elif [ -z "$BRANCH" ]; then BRANCH="$1"
            else echo -e "${RED}Too many arguments${NC}"; usage; exit 1
            fi
            shift ;;
    esac
done

if [ -z "$HOST" ]; then
    echo -e "${RED}Error: host is required${NC}"
    usage
    exit 1
fi

# Verify we're in a git repo
REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null) || {
    echo -e "${RED}Error: not in a git repository${NC}"
    exit 1
}

# Resolve registered repo name (auto-registers on first use, handles collisions)
resolve_repo_name "$REPO_ROOT"
REPO_NAME="$REPO_REGISTERED_NAME"

# Default to current branch
if [ -z "$BRANCH" ]; then
    BRANCH=$(git branch --show-current 2>/dev/null) || {
        echo -e "${RED}Error: not on a branch (detached HEAD) and no branch specified${NC}"
        exit 1
    }
    if [ -z "$BRANCH" ]; then
        echo -e "${RED}Error: not on a branch (detached HEAD) and no branch specified${NC}"
        exit 1
    fi
fi

echo -e "${BLUE}Repo:${NC} ${REPO_NAME} (${REPO_ROOT})"

# Resolve remote path: use -p if given, otherwise read remote config
if [ -z "$REMOTE_PATH" ]; then
    echo -e "${BLUE}Resolving remote repo path...${NC}"
    REMOTE_BASE=$(ssh "$HOST" bash -c "'
        BP=\$HOME
        CFG=\$HOME/.repo-transfer/config
        if [ -f \"\$CFG\" ]; then
            while IFS=\"=\" read -r k v; do
                case \"\$k\" in base_path) v=\$(echo \"\$v\" | xargs); BP=\"\${v/#\\~/\$HOME}\" ;; esac
            done < \"\$CFG\"
        fi
        echo \"\$BP\"
    '") || {
        echo -e "${YELLOW}Warning: could not read remote config, assuming ~${NC}"
        REMOTE_BASE="~"
    }
    REMOTE_PATH="$REMOTE_BASE/$REPO_NAME"
fi

# Determine local basis for incremental fetch
LOCAL_TIP=""
if [ "$FULL" = false ] && git rev-parse --verify "$BRANCH" >/dev/null 2>&1; then
    LOCAL_TIP=$(git rev-parse "$BRANCH")
fi

# Ask remote to create the bundle
REMOTE_BUNDLE="/tmp/${REPO_NAME}-fetch-$(date +%s).bundle"

echo -e "${BLUE}Creating bundle on $HOST...${NC}"

if [ -n "$LOCAL_TIP" ]; then
    # Try incremental first, fall back to full
    BUNDLE_CREATED=$(ssh "$HOST" bash -s <<REMOTEOF
        set -e
        cd "$REMOTE_PATH" 2>/dev/null || { echo "REPO_NOT_FOUND"; exit 0; }
        git rev-parse --verify "$BRANCH" >/dev/null 2>&1 || { echo "BRANCH_NOT_FOUND"; exit 0; }

        REMOTE_TIP=\$(git rev-parse "$BRANCH")
        if [ "\$REMOTE_TIP" = "$LOCAL_TIP" ]; then
            echo "UP_TO_DATE"
            exit 0
        fi

        # Try incremental
        if git merge-base --is-ancestor "$LOCAL_TIP" "$BRANCH" 2>/dev/null; then
            git bundle create "$REMOTE_BUNDLE" "$LOCAL_TIP..$BRANCH" -- 2>/dev/null && {
                echo "INCREMENTAL"
                exit 0
            }
        fi

        # Fall back to full
        git bundle create "$REMOTE_BUNDLE" "$BRANCH" -- 2>/dev/null && {
            echo "FULL"
            exit 0
        }

        echo "BUNDLE_FAILED"
REMOTEOF
    )
else
    # No local branch - need full bundle
    BUNDLE_CREATED=$(ssh "$HOST" bash -s <<REMOTEOF
        set -e
        cd "$REMOTE_PATH" 2>/dev/null || { echo "REPO_NOT_FOUND"; exit 0; }
        git rev-parse --verify "$BRANCH" >/dev/null 2>&1 || { echo "BRANCH_NOT_FOUND"; exit 0; }
        git bundle create "$REMOTE_BUNDLE" "$BRANCH" -- 2>/dev/null && {
            echo "FULL"
            exit 0
        }
        echo "BUNDLE_FAILED"
REMOTEOF
    )
fi

# Handle remote errors
case "$BUNDLE_CREATED" in
    REPO_NOT_FOUND)
        echo -e "${RED}Error: repo not found at $REMOTE_PATH on $HOST${NC}"
        exit 1 ;;
    BRANCH_NOT_FOUND)
        echo -e "${RED}Error: branch '$BRANCH' not found on remote${NC}"
        exit 1 ;;
    UP_TO_DATE)
        echo -e "${YELLOW}Already up to date.${NC}"
        exit 0 ;;
    BUNDLE_FAILED)
        echo -e "${RED}Error: failed to create bundle on remote${NC}"
        exit 1 ;;
    INCREMENTAL)
        echo -e "${BLUE}Incremental bundle created on remote${NC}" ;;
    FULL)
        echo -e "${BLUE}Full bundle created on remote${NC}" ;;
    *)
        echo -e "${RED}Unexpected response from remote: $BUNDLE_CREATED${NC}"
        exit 1 ;;
esac

# Transfer bundle back
LOCAL_BUNDLE=$(mktemp "/tmp/${REPO_NAME}-XXXXXX.bundle")
trap "rm -f '$LOCAL_BUNDLE'; ssh '$HOST' 'rm -f \"$REMOTE_BUNDLE\"' 2>/dev/null || true" EXIT

echo -e "${BLUE}Transferring bundle...${NC}"
scp -q "$HOST:$REMOTE_BUNDLE" "$LOCAL_BUNDLE"
ssh "$HOST" "rm -f '$REMOTE_BUNDLE'" 2>/dev/null || true

BUNDLE_SIZE=$(du -h "$LOCAL_BUNDLE" | cut -f1)
echo -e "Bundle: ${BUNDLE_SIZE}"

# Apply locally
CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "")

if git rev-parse --verify "$BRANCH" >/dev/null 2>&1; then
    # Branch exists locally
    if [ "$CURRENT_BRANCH" = "$BRANCH" ]; then
        # We're on the target branch
        if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null; then
            echo -e "${YELLOW}Warning: uncommitted changes - stashing${NC}"
            git stash push -m "repo-fetch auto-stash $(date +%Y%m%d-%H%M%S)"
        fi
        git fetch "$LOCAL_BUNDLE" "$BRANCH"
        if git merge --ff-only FETCH_HEAD 2>/dev/null; then
            echo -e "${GREEN}Fast-forwarded '$BRANCH'${NC}"
        else
            echo -e "${YELLOW}Cannot fast-forward. Resetting to remote state...${NC}"
            git reset --hard FETCH_HEAD
            echo -e "${GREEN}Reset '$BRANCH' to remote state${NC}"
        fi
    else
        # On a different branch - update the ref
        git fetch "$LOCAL_BUNDLE" "$BRANCH:$BRANCH"
        git checkout "$BRANCH"
        echo -e "${GREEN}Updated and checked out '$BRANCH'${NC}"
    fi
else
    # Branch doesn't exist locally - create it
    git fetch "$LOCAL_BUNDLE" "$BRANCH:$BRANCH"
    git checkout "$BRANCH"
    echo -e "${GREEN}Created and checked out '$BRANCH'${NC}"
fi

NEW_TIP=$(git rev-parse "$BRANCH")
echo -e "${GREEN}[$REPO_NAME] Fetched '$BRANCH' ($NEW_TIP) from $HOST:$REMOTE_PATH${NC}"
