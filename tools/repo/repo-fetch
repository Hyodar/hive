#!/bin/bash
# repo-fetch - Fetch a git branch from a remote machine using git bundles over SSH
#
# Usage: repo-fetch [options] <host> [refspec]
#   Refspec: <local_branch>[:<repo_name>][@<remote_branch>]
#   -p, --path <path>   Remote repo path (overrides remote config)
#   -f, --full           Force full bundle (skip incremental)
#   -h, --help           Show help
#
# Config: ~/.repo-transfer/config on the REMOTE machine controls the default base_path.

set -euo pipefail

# Source registry functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/repo-registry.sh"

# SSH identity (exported by hive main for per-worker quick-ssh)
HIVE_SSH_ID="${HIVE_SSH_ID:-}"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

usage() {
    cat <<EOF
Usage: repo-fetch [options] <host> [refspec]

Fetch a git branch from a remote machine via git bundle over SSH.
The remote creates a bundle and sends it back for local application.

The remote machine's ~/.repo-transfer/config controls where repos
live (base_path setting, defaults to ~).

Refspec format: <local_branch>[:<repo_name>][@<remote_branch>]
  main              Fetch remote 'main' from repo (dir name) into local 'main'
  main:myapp-v2     Fetch remote 'main' from 'myapp-v2' into local 'main'
  main@dev          Fetch remote 'dev' from repo (dir name) into local 'main'
  main:myapp-v2@dev Fetch remote 'dev' from 'myapp-v2' into local 'main'

Arguments:
  host      Remote hostname (Tailscale name, IP, or user@host)
  refspec   What to fetch (default: current branch, same repo name + branch)

Options:
  -p, --path <path>   Remote repo path (overrides remote config)
  -f, --full           Force full bundle (no incremental optimization)
  -h, --help           Show this help message

Examples:
  repo-fetch agent-vm
  repo-fetch agent-vm main
  repo-fetch agent-vm main:myapp-v2
  repo-fetch agent-vm main:myapp-v2@dev
  repo-fetch agent-vm main -p ~/projects/myapp
  repo-fetch user@10.0.0.5 dev --full
EOF
}

FULL=false
REMOTE_PATH=""
HOST=""
REFSPEC=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -p|--path) REMOTE_PATH="$2"; shift 2 ;;
        -f|--full) FULL=true; shift ;;
        -h|--help) usage; exit 0 ;;
        -*)
            echo -e "${RED}Unknown option: $1${NC}"
            usage; exit 1 ;;
        *)
            if [ -z "$HOST" ]; then HOST="$1"
            elif [ -z "$REFSPEC" ]; then REFSPEC="$1"
            else echo -e "${RED}Too many arguments${NC}"; usage; exit 1
            fi
            shift ;;
    esac
done

if [ -z "$HOST" ]; then
    echo -e "${RED}Error: host is required${NC}"
    usage
    exit 1
fi

# Verify we're in a git repo
REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null) || {
    echo -e "${RED}Error: not in a git repository${NC}"
    exit 1
}

DEFAULT_REPO_NAME=$(basename "$REPO_ROOT")

# Parse refspec
parse_refspec "$REFSPEC" "$DEFAULT_REPO_NAME"

# Default local branch to current branch
LOCAL_BRANCH="${PARSED_LOCAL_BRANCH}"
if [ -z "$LOCAL_BRANCH" ]; then
    LOCAL_BRANCH=$(git branch --show-current 2>/dev/null) || {
        echo -e "${RED}Error: not on a branch (detached HEAD) and no branch specified${NC}"
        exit 1
    }
    if [ -z "$LOCAL_BRANCH" ]; then
        echo -e "${RED}Error: not on a branch (detached HEAD) and no branch specified${NC}"
        exit 1
    fi
fi

REPO_NAME="$PARSED_REPO_NAME"
REMOTE_BRANCH="${PARSED_REMOTE_BRANCH:-$LOCAL_BRANCH}"

# If worker name available, resolve repo name from registry (use existing mapping)
if [ -n "${HIVE_WORKER_NAME:-}" ]; then
    ensure_workers_file 2>/dev/null && {
        # If no explicit repo name, check if this path is already registered under a name
        if [ "$PARSED_REPO_EXPLICIT" = false ]; then
            EXISTING_NAME=$(lookup_worker_repo_by_path "$HIVE_WORKER_NAME" "$REPO_ROOT")
            if [ -n "$EXISTING_NAME" ]; then
                REPO_NAME="$EXISTING_NAME"
            fi
        fi
    }
fi

echo -e "${BLUE}Fetching${NC} ${REPO_NAME}@${REMOTE_BRANCH} → ${LOCAL_BRANCH}${HIVE_WORKER_NAME:+ from ${HIVE_WORKER_NAME}}"

# Resolve remote path: use -p if given, otherwise read remote config
if [ -z "$REMOTE_PATH" ]; then
    REMOTE_BASE=$(ssh $HIVE_SSH_ID "$HOST" bash -c "'
        BP=\$HOME
        CFG=\$HOME/.repo-transfer/config
        if [ -f \"\$CFG\" ]; then
            while IFS=\"=\" read -r k v; do
                case \"\$k\" in base_path) v=\$(echo \"\$v\" | xargs); BP=\"\${v/#\\~/\$HOME}\" ;; esac
            done < \"\$CFG\"
        fi
        echo \"\$BP\"
    '") || {
        echo -e "${YELLOW}Warning: could not read remote config, assuming ~${NC}"
        REMOTE_BASE="~"
    }
    REMOTE_PATH="$REMOTE_BASE/$REPO_NAME"
fi

# Determine local basis for incremental fetch
LOCAL_TIP=""
if [ "$FULL" = false ] && git rev-parse --verify "$LOCAL_BRANCH" >/dev/null 2>&1; then
    LOCAL_TIP=$(git rev-parse "$LOCAL_BRANCH")
fi

# Ask remote to create the bundle
REMOTE_BUNDLE="/tmp/${REPO_NAME}-fetch-$(date +%s).bundle"

echo -e "${BLUE}Creating bundle on $HOST...${NC}"

if [ -n "$LOCAL_TIP" ]; then
    # Try incremental first, fall back to full
    BUNDLE_CREATED=$(ssh $HIVE_SSH_ID "$HOST" bash -s <<REMOTEOF
        set -e
        cd "$REMOTE_PATH" 2>/dev/null || { echo "REPO_NOT_FOUND"; exit 0; }
        git rev-parse --verify "$REMOTE_BRANCH" >/dev/null 2>&1 || { echo "BRANCH_NOT_FOUND"; exit 0; }

        REMOTE_TIP=\$(git rev-parse "$REMOTE_BRANCH")
        if [ "\$REMOTE_TIP" = "$LOCAL_TIP" ]; then
            echo "UP_TO_DATE"
            exit 0
        fi

        # Try incremental
        if git merge-base --is-ancestor "$LOCAL_TIP" "$REMOTE_BRANCH" 2>/dev/null; then
            git bundle create "$REMOTE_BUNDLE" "$LOCAL_TIP..$REMOTE_BRANCH" -- 2>/dev/null && {
                echo "INCREMENTAL"
                exit 0
            }
        fi

        # Fall back to full
        git bundle create "$REMOTE_BUNDLE" "$REMOTE_BRANCH" -- 2>/dev/null && {
            echo "FULL"
            exit 0
        }

        echo "BUNDLE_FAILED"
REMOTEOF
    )
else
    # No local branch - need full bundle
    BUNDLE_CREATED=$(ssh $HIVE_SSH_ID "$HOST" bash -s <<REMOTEOF
        set -e
        cd "$REMOTE_PATH" 2>/dev/null || { echo "REPO_NOT_FOUND"; exit 0; }
        git rev-parse --verify "$REMOTE_BRANCH" >/dev/null 2>&1 || { echo "BRANCH_NOT_FOUND"; exit 0; }
        git bundle create "$REMOTE_BUNDLE" "$REMOTE_BRANCH" -- 2>/dev/null && {
            echo "FULL"
            exit 0
        }
        echo "BUNDLE_FAILED"
REMOTEOF
    )
fi

# Handle remote errors
case "$BUNDLE_CREATED" in
    REPO_NOT_FOUND)
        echo -e "${RED}Error: repo '$REPO_NAME' not found at $REMOTE_PATH on $HOST${NC}"
        exit 1 ;;
    BRANCH_NOT_FOUND)
        echo -e "${RED}Error: branch '$REMOTE_BRANCH' not found on remote repo '$REPO_NAME'${NC}"
        exit 1 ;;
    UP_TO_DATE)
        echo -e "${YELLOW}[$REPO_NAME] Already up to date.${NC}"
        exit 0 ;;
    BUNDLE_FAILED)
        echo -e "${RED}Error: failed to create bundle on remote${NC}"
        exit 1 ;;
    INCREMENTAL)
        echo -e "${BLUE}Incremental bundle created on remote${NC}" ;;
    FULL)
        echo -e "${BLUE}Full bundle created on remote${NC}" ;;
    *)
        echo -e "${RED}Unexpected response from remote: $BUNDLE_CREATED${NC}"
        exit 1 ;;
esac

# Transfer bundle back
LOCAL_BUNDLE=$(mktemp "/tmp/${REPO_NAME}-XXXXXX.bundle")
trap "rm -f '$LOCAL_BUNDLE'; ssh $HIVE_SSH_ID '$HOST' 'rm -f \"$REMOTE_BUNDLE\"' 2>/dev/null || true" EXIT

echo -e "${BLUE}Transferring bundle...${NC}"
scp $HIVE_SSH_ID -q "$HOST:$REMOTE_BUNDLE" "$LOCAL_BUNDLE"
ssh $HIVE_SSH_ID "$HOST" "rm -f '$REMOTE_BUNDLE'" 2>/dev/null || true

BUNDLE_SIZE=$(du -h "$LOCAL_BUNDLE" | cut -f1)
echo -e "Bundle: ${BUNDLE_SIZE}"

# Apply locally
CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "")

if git rev-parse --verify "$LOCAL_BRANCH" >/dev/null 2>&1; then
    # Branch exists locally
    if [ "$CURRENT_BRANCH" = "$LOCAL_BRANCH" ]; then
        # We're on the target branch
        if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null; then
            echo -e "${YELLOW}Warning: uncommitted changes - stashing${NC}"
            git stash push -m "repo-fetch auto-stash $(date +%Y%m%d-%H%M%S)"
        fi
        git fetch "$LOCAL_BUNDLE" "$REMOTE_BRANCH"
        if git merge --ff-only FETCH_HEAD 2>/dev/null; then
            echo -e "${GREEN}Fast-forwarded '$LOCAL_BRANCH'${NC}"
        else
            echo -e "${YELLOW}Cannot fast-forward. Resetting to remote state...${NC}"
            git reset --hard FETCH_HEAD
            echo -e "${GREEN}Reset '$LOCAL_BRANCH' to remote state${NC}"
        fi
    else
        # On a different branch - update the ref
        git fetch "$LOCAL_BUNDLE" "$REMOTE_BRANCH:$LOCAL_BRANCH"
        git checkout "$LOCAL_BRANCH"
        echo -e "${GREEN}Updated and checked out '$LOCAL_BRANCH'${NC}"
    fi
else
    # Branch doesn't exist locally - create it
    git fetch "$LOCAL_BUNDLE" "$REMOTE_BRANCH:$LOCAL_BRANCH"
    git checkout "$LOCAL_BRANCH"
    echo -e "${GREEN}Created and checked out '$LOCAL_BRANCH'${NC}"
fi

NEW_TIP=$(git rev-parse "$LOCAL_BRANCH")
echo -e "${GREEN}[$REPO_NAME] Fetched ${REPO_NAME}@${REMOTE_BRANCH} → ${LOCAL_BRANCH} ($NEW_TIP) from $HOST:$REMOTE_PATH${NC}"
