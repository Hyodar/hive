#!/usr/bin/env bash
# codex-account - Manage and switch between multiple Codex accounts
# Inspired by https://github.com/Sls0n/codex-account-switcher (codex-auth)
# Linux-only. Uses symlinks for zero-copy switching.
#
# Works like nvm: `use` sets the account for the current session,
# `default` sets what new shells start with. Add to .bashrc/.zshrc:
#   eval "$(codex-account init)"

set -euo pipefail

CODEX_DIR="$HOME/.codex"
ACCOUNTS_DIR="$CODEX_DIR/accounts"
AUTH_FILE="$CODEX_DIR/auth.json"
CURRENT_FILE="$CODEX_DIR/current"
DEFAULT_FILE="$CODEX_DIR/default"
ACCOUNT_NAME_PATTERN='^[a-zA-Z0-9][a-zA-Z0-9._-]*$'

die() { echo "Error: $*" >&2; exit 1; }

validate_name() {
    local name="$1"
    name="${name%.json}"
    [[ -z "$name" ]] && die "Account name cannot be empty"
    [[ "$name" =~ $ACCOUNT_NAME_PATTERN ]] || die "Invalid account name '$name'. Use alphanumeric, dots, dashes, underscores."
    echo "$name"
}

get_current() {
    if [[ -f "$CURRENT_FILE" ]]; then
        local name
        name=$(<"$CURRENT_FILE")
        name="${name%$'\n'}"
        [[ -n "$name" ]] && echo "$name" && return
    fi
    # Fallback: resolve symlink
    if [[ -L "$AUTH_FILE" ]]; then
        local target
        target=$(readlink "$AUTH_FILE")
        target=$(basename "$target")
        echo "${target%.json}"
        return
    fi
    echo ""
}

get_default() {
    if [[ -f "$DEFAULT_FILE" ]]; then
        local name
        name=$(<"$DEFAULT_FILE")
        name="${name%$'\n'}"
        [[ -n "$name" ]] && echo "$name" && return
    fi
    echo ""
}

cmd_setup() {
    [[ $# -lt 1 ]] && die "Usage: codex-account setup <name>"
    local name
    name=$(validate_name "$1")

    echo "Setting up Codex account \"$name\"..."
    echo ""

    # Logout current session if one exists
    if [[ -f "$AUTH_FILE" || -L "$AUTH_FILE" ]]; then
        echo "Logging out of current Codex session..."
        codex auth logout 2>/dev/null || true
    fi

    # Login to new account
    echo "Starting Codex login..."
    codex auth login || die "Login failed or was cancelled."

    # Save the new credentials
    cmd_save "$name"
}

cmd_save() {
    [[ $# -lt 1 ]] && die "Usage: codex-account save <name>"
    local name
    name=$(validate_name "$1")

    [[ -f "$AUTH_FILE" || -L "$AUTH_FILE" ]] || die "No auth file found at $AUTH_FILE. Log in to Codex first."

    mkdir -p "$ACCOUNTS_DIR"

    # Copy the actual file content (resolve symlink if needed)
    cp "$(readlink -f "$AUTH_FILE")" "$ACCOUNTS_DIR/$name.json"
    chmod 600 "$ACCOUNTS_DIR/$name.json"

    echo "$name" > "$CURRENT_FILE"

    # Set as default if no default exists yet
    if [[ ! -f "$DEFAULT_FILE" ]] || [[ -z "$(get_default)" ]]; then
        echo "$name" > "$DEFAULT_FILE"
    fi

    echo "Saved current Codex auth as \"$name\"."
}

# use: switch for the current session (does NOT change the default)
cmd_use() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        # Interactive selection
        local accounts=()
        if [[ -d "$ACCOUNTS_DIR" ]]; then
            while IFS= read -r -d '' f; do
                accounts+=("$(basename "${f%.json}")")
            done < <(find "$ACCOUNTS_DIR" -maxdepth 1 -name '*.json' -type f -print0 | sort -z)
        fi
        [[ ${#accounts[@]} -eq 0 ]] && die "No saved accounts. Run 'codex-account save <name>' first."

        local current default_name
        current=$(get_current)
        default_name=$(get_default)

        echo "Select account:"
        local i=1
        for acct in "${accounts[@]}"; do
            local mark=" "
            [[ "$acct" == "$current" ]] && mark="*"
            local suffix=""
            [[ "$acct" == "$default_name" ]] && suffix=" (default)"
            echo "  $mark $i) $acct$suffix"
            ((i++))
        done

        echo ""
        read -rp "Enter number: " choice
        [[ "$choice" =~ ^[0-9]+$ ]] || die "Invalid selection"
        [[ "$choice" -ge 1 && "$choice" -le ${#accounts[@]} ]] || die "Selection out of range"
        name="${accounts[$((choice - 1))]}"
    else
        name=$(validate_name "$name")
    fi

    _switch_to "$name"
}

# Internal: perform the actual switch
_switch_to() {
    local name="$1"
    local quiet="${2:-}"

    local source="$ACCOUNTS_DIR/$name.json"
    [[ -f "$source" ]] || die "Account \"$name\" not found. Run 'codex-account list' to see saved accounts."

    mkdir -p "$CODEX_DIR"

    # Replace auth.json with symlink
    rm -f "$AUTH_FILE"
    ln -s "$(readlink -f "$source")" "$AUTH_FILE"

    echo "$name" > "$CURRENT_FILE"

    if [[ "$quiet" != "quiet" ]]; then
        echo "Switched Codex auth to \"$name\"."
    fi
}

# default: set (or show) the default account for new shells
cmd_default() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        # Show current default
        local default_name
        default_name=$(get_default)
        if [[ -n "$default_name" ]]; then
            echo "$default_name"
        else
            echo "No default set. Run 'codex-account default <name>' to set one."
        fi
        return
    fi

    name=$(validate_name "$name")

    local source="$ACCOUNTS_DIR/$name.json"
    [[ -f "$source" ]] || die "Account \"$name\" not found. Run 'codex-account list' to see saved accounts."

    echo "$name" > "$DEFAULT_FILE"

    # Also switch to it now
    _switch_to "$name" quiet

    echo "Default Codex account set to \"$name\"."
}

# init: output shell snippet for .bashrc/.zshrc
# Installs wrapper functions so `use` is truly per-session (like nvm).
cmd_init() {
    cat << 'INITEOF'
# codex-account shell init — per-session account switching (like nvm)
_codex_account_session=""

# Wrap codex-account: 'use' only sets a session variable (no global switch)
codex-account() {
    case "${1:-}" in
        use)
            shift
            if [[ $# -eq 0 ]]; then
                # Interactive — delegate to real command, then sync session var
                command codex-account use
                local _cf="$HOME/.codex/current"
                [[ -f "$_cf" ]] && { _codex_account_session=$(<"$_cf"); _codex_account_session="${_codex_account_session%$'\n'}"; }
            else
                local _name="${1%.json}"
                local _src="$HOME/.codex/accounts/$_name.json"
                if [[ ! -f "$_src" ]]; then
                    echo "Error: Account \"$_name\" not found. Run 'codex-account list' to see saved accounts." >&2
                    return 1
                fi
                _codex_account_session="$_name"
                echo "Using Codex account \"$_name\" (this session only)."
            fi
            ;;
        default|save|setup)
            # These change global state — delegate and sync session var
            command codex-account "$@"
            local _cf="$HOME/.codex/current"
            [[ -f "$_cf" ]] && { _codex_account_session=$(<"$_cf"); _codex_account_session="${_codex_account_session%$'\n'}"; }
            ;;
        *)
            command codex-account "$@"
            ;;
    esac
}

# Wrap codex: lazily swap credentials to match this session's account
codex() {
    if [[ -n "${_codex_account_session:-}" ]]; then
        local _cf="$HOME/.codex/current"
        local _cur=""
        [[ -f "$_cf" ]] && { _cur=$(<"$_cf"); _cur="${_cur%$'\n'}"; }
        if [[ "$_cur" != "$_codex_account_session" ]]; then
            command codex-account use "$_codex_account_session" > /dev/null 2>&1 || true
        fi
    fi
    command codex "$@"
}

# Restore default account on shell startup
_codex_account_df="$HOME/.codex/default"
if [[ -f "$_codex_account_df" ]]; then
    _codex_account_session=$(<"$_codex_account_df")
    _codex_account_session="${_codex_account_session%$'\n'}"
    if [[ -n "$_codex_account_session" ]]; then
        command codex-account use "$_codex_account_session" > /dev/null 2>&1 || true
    fi
fi
unset _codex_account_df
INITEOF
}

cmd_list() {
    if [[ ! -d "$ACCOUNTS_DIR" ]]; then
        echo "No saved Codex accounts yet. Run 'codex-account save <name>'."
        return
    fi

    local accounts=()
    while IFS= read -r -d '' f; do
        accounts+=("$(basename "${f%.json}")")
    done < <(find "$ACCOUNTS_DIR" -maxdepth 1 -name '*.json' -type f -print0 | sort -z)

    [[ ${#accounts[@]} -eq 0 ]] && { echo "No saved Codex accounts yet. Run 'codex-account save <name>'."; return; }

    local current default_name
    current=$(get_current)
    default_name=$(get_default)

    for acct in "${accounts[@]}"; do
        local mark=" "
        [[ "$acct" == "$current" ]] && mark="*"
        local suffix=""
        [[ "$acct" == "$default_name" ]] && suffix=" (default)"
        echo "$mark $acct$suffix"
    done
}

cmd_current() {
    local name
    name=$(get_current)
    if [[ -n "$name" ]]; then
        echo "$name"
    else
        echo "No Codex account is active yet."
    fi
}

show_help() {
    echo "codex-account - Manage multiple Codex accounts (nvm-style)"
    echo ""
    echo "Usage: codex-account <command> [args]"
    echo ""
    echo "Commands:"
    echo "  setup <name>     Logout, login, and save as a named account"
    echo "  save <name>      Save current ~/.codex/auth.json as a named account"
    echo "  use [name]       Switch to a named account for the current session"
    echo "  default [name]   Set (or show) the default account for new shells"
    echo "  init             Output shell init script (eval in .bashrc/.zshrc)"
    echo "  list             List all saved accounts (* = active, default marked)"
    echo "  current          Show the currently active account name"
    echo "  help             Show this help"
    echo ""
    echo "Shell init (add to .bashrc or .zshrc):"
    echo "  eval \"\$(codex-account init)\""
    echo ""
    echo "With init, 'use' is truly per-session: each terminal keeps its own"
    echo "account, and a 'codex' wrapper restores it before each invocation."
    echo "Without init, 'use' changes the global symlink immediately."
}

case "${1:-help}" in
    setup)   shift; cmd_setup "$@" ;;
    save)    shift; cmd_save "$@" ;;
    use)     shift; cmd_use "$@" ;;
    default) shift; cmd_default "$@" ;;
    init)    cmd_init ;;
    list|ls) cmd_list ;;
    current) cmd_current ;;
    help|--help|-h) show_help ;;
    *)       die "Unknown command '$1'. Run 'codex-account help' for usage." ;;
esac
